<%- include('layouts/main', {
    title: 'Flight Planner',
    activePage: 'planner',
    head: `
    <style>
        .planner-frame {
            width: 100%;
            height: 100%;
            border: 0;
            background: #0f172a;
        }
    </style>
    `,
    body: `
    <div class="content-area no-padding">
        <iframe
            id="plannerFrame"
            class="planner-frame"
            src="/assets/planner/index.html"
            title="Flight Planner"
            loading="lazy"
            referrerpolicy="no-referrer"
        ></iframe>
    </div>
    `,
    scripts: `
    <script>
        (() => {
            const frame = document.getElementById('plannerFrame');
            if (!frame) return;

            const declarationUrl = '/api/blender/flight-declarations';
            const atcBase = window.__ATC_API_BASE__ || '/api/atc';
            const complianceUrl = atcBase.replace(/\/$/, '') + '/v1/compliance/evaluate';
            const PREFILL_KEY = 'plannerPrefill';

            const COMPLIANCE_LIMITS = (() => {
                const overrides = window.__ATC_COMPLIANCE_LIMITS__ || {};
                return {
                    maxWindMps: safeNumber(overrides.maxWindMps) ?? 12,
                    maxGustMps: safeNumber(overrides.maxGustMps) ?? 15,
                    maxPrecipMm: safeNumber(overrides.maxPrecipMm) ?? 2,
                    defaultClearanceM: safeNumber(overrides.defaultClearanceM) ?? 60
                };
            })();

            const COMPLIANCE_DEFAULTS = {
                batteryCapacityMin: 25,
                batteryReserveMin: 5,
                clearanceM: COMPLIANCE_LIMITS.defaultClearanceM,
                operationType: 1
            };

            function toRad(deg) {
                return deg * Math.PI / 180;
            }

            function haversineDistance(a, b) {
                const R = 6371000;
                const dLat = toRad(b.lat - a.lat);
                const dLon = toRad(b.lon - a.lon);
                const lat1 = toRad(a.lat);
                const lat2 = toRad(b.lat);
                const h = Math.sin(dLat / 2) ** 2
                    + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
                return 2 * R * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
            }

            function computeRouteDistance(points) {
                if (!Array.isArray(points) || points.length < 2) return 0;
                let total = 0;
                for (let i = 1; i < points.length; i += 1) {
                    total += haversineDistance(points[i - 1], points[i]);
                }
                return total;
            }

            function getAltitudeRange(points) {
                let minAlt = Infinity;
                let maxAlt = -Infinity;
                points.forEach((pt) => {
                    const alt = Number(pt.alt);
                    if (!Number.isFinite(alt)) return;
                    minAlt = Math.min(minAlt, alt);
                    maxAlt = Math.max(maxAlt, alt);
                });
                if (!Number.isFinite(minAlt)) minAlt = 0;
                if (!Number.isFinite(maxAlt)) maxAlt = 0;
                return { minAlt, maxAlt };
            }

            function safeNumber(value) {
                const num = Number(value);
                return Number.isFinite(num) ? num : null;
            }

            function mapConflictList(conflicts) {
                if (!Array.isArray(conflicts)) return [];
                return conflicts.map((conflict) => ({
                    id: conflict.id,
                    name: conflict.name,
                    distanceM: safeNumber(conflict.distance_m) ?? safeNumber(conflict.distanceM),
                    severity: conflict.severity || 'conflict'
                }));
            }

            function mapHazardList(hazards) {
                if (!Array.isArray(hazards)) return [];
                return hazards.map((hazard) => ({
                    id: hazard.id,
                    name: hazard.name,
                    lat: safeNumber(hazard.lat),
                    lon: safeNumber(hazard.lon),
                    radiusM: safeNumber(hazard.radius_m) ?? safeNumber(hazard.radiusM),
                    heightM: safeNumber(hazard.height_m) ?? safeNumber(hazard.heightM),
                    hazardType: hazard.hazard_type || hazard.hazardType || 'unknown',
                    source: hazard.source || null,
                    distanceM: safeNumber(hazard.distance_m) ?? safeNumber(hazard.distanceM)
                }));
            }

            function normalizeComplianceResponse(result) {
                const report = result?.report;
                if (!report) return null;

                const route = report.route || {};
                const checks = report.checks || {};
                const weather = checks.weather || {};
                const battery = checks.battery || {};
                const population = checks.population || {};
                const obstacles = checks.obstacles || {};

                return {
                    generated_at: report.generated_at,
                    overall_status: report.overall_status,
                    route: {
                        distanceM: safeNumber(route.distance_m) ?? 0,
                        estimatedMinutes: safeNumber(route.estimated_minutes) ?? 0,
                        hasRoute: !!route.has_route
                    },
                    checks: {
                        weather: {
                            status: weather.status || 'pending',
                            message: weather.message || '',
                            windMps: safeNumber(weather.wind_mps),
                            gustMps: safeNumber(weather.gust_mps),
                            precipMm: safeNumber(weather.precip_mm),
                            maxWindMps: safeNumber(weather.max_wind_mps),
                            maxGustMps: safeNumber(weather.max_gust_mps),
                            maxPrecipMm: safeNumber(weather.max_precip_mm),
                            source: weather.source || null
                        },
                        battery: {
                            status: battery.status || 'pending',
                            message: battery.message || '',
                            estimatedMinutes: safeNumber(battery.estimated_minutes),
                            capacityMin: safeNumber(battery.capacity_min),
                            reserveMin: safeNumber(battery.reserve_min),
                            remainingMin: safeNumber(battery.remaining_min),
                            cruiseSpeedMps: safeNumber(battery.cruise_speed_mps)
                        },
                        population: {
                            status: population.status || 'pending',
                            message: population.message || '',
                            density: safeNumber(population.density),
                            classification: population.classification || null,
                            buildingCount: safeNumber(population.building_count),
                            estimatedPopulation: safeNumber(population.estimated_population),
                            areaKm2: safeNumber(population.area_km2),
                            source: population.source || null
                        },
                        obstacles: {
                            status: obstacles.status || 'pending',
                            message: obstacles.message || '',
                            clearanceM: safeNumber(obstacles.clearance_m),
                            conflicts: mapConflictList(obstacles.conflicts),
                            hazards: mapHazardList(obstacles.hazards),
                            obstacleCount: safeNumber(obstacles.obstacle_count) ?? 0,
                            truncated: !!obstacles.truncated
                        }
                    },
                    override: { enabled: false, notes: '' },
                    blocking: Array.isArray(result?.blocking) ? result.blocking : [],
                    violations: Array.isArray(result?.violations) ? result.violations : [],
                    ok: !!result?.ok
                };
            }

            async function fetchComplianceReport(points, speedMps, clearanceM, droneId) {
                if (!points.length) return null;
                const waypoints = points.map((pt) => ({
                    lat: pt.lat,
                    lon: pt.lon,
                    altitude_m: Number.isFinite(pt.alt) ? pt.alt : 0
                }));
                const payload = {
                    waypoints,
                    metadata: {
                        drone_speed_mps: speedMps,
                        battery_capacity_min: COMPLIANCE_DEFAULTS.batteryCapacityMin,
                        battery_reserve_min: COMPLIANCE_DEFAULTS.batteryReserveMin,
                        clearance_m: clearanceM,
                        operation_type: COMPLIANCE_DEFAULTS.operationType,
                        compliance_override_enabled: false
                    }
                };
                if (droneId) {
                    payload.drone_id = droneId;
                }
                const response = await fetch(complianceUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify(payload)
                });
                if (!response.ok) return null;
                const result = await response.json();
                return {
                    ...result,
                    compliance: normalizeComplianceResponse(result)
                };
            }

            function buildGeoJson(points, minAlt, maxAlt, startIso, endIso, compliance) {
                const coordinates = points.map((pt) => [pt.lon, pt.lat]);
                const geometry = coordinates.length === 1
                    ? { type: 'Point', coordinates: coordinates[0] }
                    : { type: 'LineString', coordinates };

                return {
                    type: 'FeatureCollection',
                    features: [
                        {
                            type: 'Feature',
                            geometry,
                            properties: {
                                min_altitude: { meters: minAlt, datum: 'W84' },
                                max_altitude: { meters: maxAlt, datum: 'W84' },
                                start_time: startIso,
                                end_time: endIso,
                                compliance: compliance
                            }
                        }
                    ]
                };
            }

            function generatePlannerFlightId() {
                if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                    return crypto.randomUUID();
                }
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            function resolvePlannerFlightId(routeData) {
                if (!routeData || typeof routeData !== 'object') {
                    return generatePlannerFlightId();
                }
                const existing = routeData.flightId || routeData.flight_id;
                if (existing) return existing;
                const generated = generatePlannerFlightId();
                routeData.flightId = generated;
                return generated;
            }

            function extractDeclarationId(payload) {
                if (!payload || typeof payload !== 'object') return null;
                return payload.id
                    || payload.flight_declaration_id
                    || payload.flight_declaration?.id
                    || null;
            }

            function requiresDeclaration(win) {
                const user = win?.APP_USER;
                if (!user) return false;
                return user.role !== 'authority';
            }

            function queuePlannerPrefill(prefill) {
                try {
                    sessionStorage.setItem(PREFILL_KEY, JSON.stringify(prefill));
                } catch (error) {
                    console.warn('Unable to persist planner prefill:', error);
                }
                window.location.href = '/control/missions/plan?prefill=planner';
            }

            async function submitDeclaration(payload) {
                const response = await fetch(declarationUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify(payload)
                });
                const body = await response.text();
                let parsed = null;
                try {
                    parsed = body ? JSON.parse(body) : null;
                } catch (error) {
                    parsed = null;
                }
                return { response, parsed, raw: body };
            }

            async function createDeclarationFromRoute(routeData, win) {
                if (!routeData || typeof routeData !== 'object') return null;
                const existingId = routeData.blenderDeclarationId || routeData.blender_declaration_id;
                if (existingId) return existingId;

                const rawWaypoints = Array.isArray(routeData.waypoints) ? routeData.waypoints : [];
                const points = rawWaypoints.map((wp) => ({
                    lat: wp.lat,
                    lon: wp.lon,
                    alt: Number.isFinite(wp.alt) ? wp.alt : wp.altitude_m
                })).filter((pt) => Number.isFinite(pt.lat) && Number.isFinite(pt.lon));
                if (!points.length) return null;

                const flightId = resolvePlannerFlightId(routeData);
                const defaultSpeed = safeNumber(win?.FlightPlanner?.CONFIG?.DRONE_SPEED_MPS) || 15;
                const speedMps = safeNumber(routeData.droneSpeedMps) || defaultSpeed;
                const distanceM = computeRouteDistance(points);
                const durationSec = speedMps > 0 ? distanceM / speedMps : 0;

                const start = new Date(Date.now() + 5 * 60 * 1000);
                const end = new Date(start.getTime() + Math.max(durationSec, 300) * 1000);

                const altRange = getAltitudeRange(points);
                const selectedDroneId = win?.FlightPlanner?.getSelectedDroneId?.();
                const droneId = selectedDroneId || ('PLANNER-' + flightId);
                const complianceResult = await fetchComplianceReport(
                    points,
                    speedMps,
                    COMPLIANCE_DEFAULTS.clearanceM,
                    droneId
                );
                const compliance = complianceResult?.compliance;
                if (compliance) {
                    compliance.atc_plan_id = flightId;
                }
                const weatherCheck = compliance?.checks?.weather;
                const populationCheck = compliance?.checks?.population;
                const obstaclesCheck = compliance?.checks?.obstacles;

                const declarationPayload = {
                    flight_declaration_geo_json: buildGeoJson(
                        points,
                        altRange.minAlt,
                        altRange.maxAlt,
                        start.toISOString(),
                        end.toISOString(),
                        compliance
                    ),
                    start_datetime: start.toISOString(),
                    end_datetime: end.toISOString(),
                    submitted_by: win?.APP_USER?.email || 'planner@atc.local',
                    type_of_operation: COMPLIANCE_DEFAULTS.operationType,
                    originating_party: 'Planner ' + flightId,
                    aircraft_id: droneId
                };

                const prefill = {
                    source: 'planner',
                    flightId: flightId,
                    droneId: droneId,
                    waypoints: points,
                    minAltitude: altRange.minAlt,
                    maxAltitude: altRange.maxAlt,
                    cruiseSpeedMps: speedMps,
                    missionName: 'Planner ' + flightId,
                    missionType: 'survey',
                    operationType: COMPLIANCE_DEFAULTS.operationType,
                    missionStart: start.toISOString(),
                    missionEnd: end.toISOString(),
                    batteryCapacityMin: COMPLIANCE_DEFAULTS.batteryCapacityMin,
                    batteryReserveMin: COMPLIANCE_DEFAULTS.batteryReserveMin,
                    weather: weatherCheck ? {
                        windMps: weatherCheck.windMps,
                        gustMps: weatherCheck.gustMps,
                        precipMm: weatherCheck.precipMm
                    } : null,
                    populationDensity: populationCheck?.density ?? null,
                    obstacleClearanceM: obstaclesCheck?.clearanceM ?? COMPLIANCE_DEFAULTS.clearanceM
                };

                if (!compliance || complianceResult?.ok === false) {
                    if (typeof win.showToast === 'function') {
                        win.showToast('Compliance review required. Redirecting for manual review.', 'warn');
                    }
                    queuePlannerPrefill(prefill);
                    return null;
                }

                const { response, parsed, raw } = await submitDeclaration(declarationPayload);
                if (response.ok) {
                    const declarationId = extractDeclarationId(parsed);
                    if (!declarationId) {
                        throw new Error('Flight Declaration response missing id.');
                    }
                    if (typeof win.showToast === 'function') {
                        win.showToast('Flight Declaration submitted to Flight Blender.', 'success');
                    }
                    return declarationId;
                }

                if (response.status === 400) {
                    if (typeof win.showToast === 'function') {
                        win.showToast('Compliance review required. Opening Mission Plan.', 'warn');
                    }
                    queuePlannerPrefill(prefill);
                    return null;
                }

                if (typeof win.showToast === 'function') {
                    win.showToast('Flight Declaration failed: ' + response.status + ' ' + (parsed?.message || raw), 'error');
                }
                throw new Error('Flight Declaration failed: ' + response.status);
            }

            function patchPlanner(win) {
                if (!win || !win.FlightPlanner) return false;
                if (win.FlightPlanner.__atcMerged) return true;

                const originalSubmit = win.FlightPlanner.submitToATC;
                if (typeof originalSubmit !== 'function') return false;

                win.FlightPlanner.submitToATC = async function (routeData) {
                    const needsDeclaration = requiresDeclaration(win);
                    if (needsDeclaration) {
                        const declarationId = await createDeclarationFromRoute(routeData, win);
                        if (!declarationId) {
                            throw new Error('Flight declaration required before ATC submission.');
                        }
                        if (routeData && typeof routeData === 'object') {
                            routeData.blenderDeclarationId = declarationId;
                        }
                    }

                    return originalSubmit(routeData);
                };

                win.FlightPlanner.__atcMerged = true;
                return true;
            }

            function waitForPlanner() {
                const win = frame.contentWindow;
                if (!win) return;

                if (patchPlanner(win)) return;

                let attempts = 0;
                const timer = setInterval(() => {
                    attempts += 1;
                    if (patchPlanner(win) || attempts > 50) {
                        clearInterval(timer);
                    }
                }, 100);
            }

            frame.addEventListener('load', waitForPlanner);
        })();
    </script>
    `
}) %>
