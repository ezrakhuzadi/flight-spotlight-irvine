<!DOCTYPE html>
<html lang="en">

<head>
  <title>Openskies Flight Spotlight</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="icon" href="/assets/img/favicon.png" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <link type="text/css" rel="stylesheet" href="/assets/css/bootstrap.min.css" />
  <link type="text/css" rel="stylesheet" href="/assets/css/bootstrap-icons.css" />
  <link rel="stylesheet" type="text/css" href="/assets/css/base.css" />
  <link rel="stylesheet" href="/assets/js/humane/flatty.css" />
  <script type="text/javascript" src="/assets/js/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/assets/js/bootstrap/bootstrap.bundle.min.js"></script>
  <script type="text/javascript" src="/assets/js/socket.io/socket.io.min.js"></script>
  <script type="text/javascript" src="/assets/js/humane/humane.min.js"></script>
  <script src="/assets/Build/Cesium/Cesium.js"></script>
  <script src="/assets/js/safe-corridor.js"></script>

  <style>
    @import url(/assets/Build/Cesium/Widgets/widgets.css);
  </style>
</head>

<body>
  <%- include('navigation') -%>

    <div class="app-container">
      <div class="sidebar-panel">

        <!-- Status / Spinner -->
        <div class="d-none loading-spinner mb-3" id="spinner-cont">
          <div class="d-flex align-items-center text-accent">
            <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
            <small>Live Stream Active</small>
          </div>
        </div>

        <!-- Manual Controls (Hidden when streaming) -->
        <div id="manual_spotlight_controls" class="card mb-4">
          <div class="card-body">
            <h6 class="card-title text-uppercase text-muted mb-3" style="font-size: 0.75rem; letter-spacing: 1px;">Area
              Selection</h6>
            <p class="card-text small mb-3">
              <span id="lat_lng" class="text-mono">
                Lat: <span id="spotlight_latitude" class="text-white">--</span> <br>
                Lng: <span id="spotlight_longitude" class="text-white">--</span>
              </span>
            </p>
            <button onclick="stream_flights()" class="btn btn-primary w-100" id="retrive_flights" type="submit">
              <i class="bi bi-broadcast me-2"></i>Stream Flights
            </button>
            <div class="mt-2 text-center">
              <small class="text-muted" style="font-size: 0.7rem;">Pan map to area & click stream</small>
            </div>
          </div>
        </div>

        <!-- Description / Info -->
        <p id="clicked-entity-description" class="mb-3 text-white small"></p>
        <div class="live-updates mb-3" id="live-updates">
          <ul class="list-unstyled" id="latest-status"></ul>
        </div>

        <!-- Flight List Panel -->
        <div id="flight-list-container" class="card flex-fill">
          <div class="card-header d-flex justify-content-between align-items-center border-0 pb-0 pt-3 bg-transparent">
            <h6 class="text-uppercase text-muted mb-0" style="font-size: 0.75rem; letter-spacing: 1px;">Active Flights
            </h6>
            <span id="flight-count" class="badge bg-accent rounded-pill">0</span>
          </div>
          <div class="card-body p-0 mt-2" style="overflow-y: auto;">
            <div id="flight-list" class="h-100">
              <table class="table table-hover table-borderless table-sm align-middle mb-0" style="font-size: 0.85rem;">
                <thead class="text-muted border-bottom border-secondary" style="font-size: 0.75rem;">
                  <tr>
                    <th class="ps-3">ID</th>
                    <th>Alt</th>
                    <th>Speed</th>
                  </tr>
                </thead>
                <tbody id="flight-list-body" class="text-white">
                  <!-- Populated by JS -->
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <!-- Footer Info -->
        <div class="mt-auto pt-3 border-top border-secondary text-muted small" style="font-size: 0.7rem;">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <span>System: <%= userProfile.email %></span>
            <span id="connectivity_status_badge"><i class="bi bi-circle-fill text-secondary"
                style="font-size: 8px;"></i></span>
          </div>
          <p class="mb-0">
            Flight Blender: <span id="connectivity_status">Check</span>
            <button class="btn btn-link p-0 ms-1 text-accent" onclick="check_blender_connectivity()"
              style="vertical-align: baseline; font-size: inherit;">
              <i class="bi bi-arrow-repeat"></i>
            </button>
          </p>
          <p class="mb-0 mt-1">
            <a href="https://blog.openskies.sh" target="_blank"
              class="text-secondary text-decoration-none hover-white">Help & Documentation</a>
          </p>
        </div>
      </div>

      <div class="map-panel">
        <div id="cesiumContainer"></div>
        <%- include('camera_controls') %>

      </div>
    </div>

    <!-- Robust Data Injection: Store data in a non-executable script block -->
    <script id="server_data" type="application/json">
        <%- JSON.stringify(data) %>
    </script>

    <script type="text/javascript">
      console.log("Spotlight script loaded");
      var socketHost = location.origin.replace(/^http/, 'ws');
      let clicked_entity = document.getElementById("clicked-entity-description");
      let list = document.getElementById("latest-status");
      var addToList = function (item_value) {
        while (list.children.length >= 3) {
          list.removeChild(list.firstChild);
        }
        var item = document.createElement("li");
        item.innerHTML = item_value;
        list.appendChild(item);
      }

      var clearList = function () {
        list.innerHTML = "";
      }

      const email = '<%= userProfile.email %>';

      let cameraMode = 'free'; // free, orbit, cockpit
      let trackedDroneId = null;

      function setCameraMode(mode) {
        cameraMode = mode;
        console.log("Camera Mode:", mode);

        if (mode === 'free') {
          viewer.trackedEntity = undefined;
        } else if (mode === 'orbit') {
          if (trackedDroneId && droneEntities.has(trackedDroneId)) {
            viewer.trackedEntity = droneEntities.get(trackedDroneId);
          }
        } else if (mode === 'cockpit') {
          viewer.trackedEntity = undefined; // We manually update for cockpit
        }

        // Update button styles
        document.querySelectorAll('#camera-controls button').forEach(btn => {
          // Check if the button's text content (case-insensitive) includes the mode
          const btnText = btn.textContent.toLowerCase();
          const modeText = mode.toLowerCase();

          if (btnText.includes(modeText)) {
            btn.classList.add('active');
            btn.classList.remove('btn-outline-light', 'btn-outline-secondary');
            btn.classList.add('btn-primary');
          } else {
            btn.classList.remove('active', 'btn-primary');
            // Reset to default outline based on original state or a generic one
            if (btnText.includes('orbit')) {
              btn.classList.add('btn-outline-light');
            } else if (btnText.includes('cockpit')) {
              btn.classList.add('btn-outline-light'); // Or btn-outline-primary if that was its original
            } else if (btnText.includes('free')) {
              btn.classList.add('btn-outline-secondary');
            }
          }
        });
      }

      // ========== TIME OF DAY CONTROLS ==========
      let currentTOD = 'realtime'; // Track current time of day mode

      function setTimeOfDay(mode) {
        currentTOD = mode;
        console.log("Time of Day:", mode);

        if (mode === 'realtime') {
          // Use real-world current time
          viewer.clock.currentTime = Cesium.JulianDate.now();
          viewer.clock.shouldAnimate = true;
          viewer.clock.multiplier = 1; // Real-time speed
        } else if (mode === 'day') {
          // Set to noon UTC (adjust for local if needed)
          const noon = new Date();
          noon.setUTCHours(12, 0, 0, 0);
          viewer.clock.currentTime = Cesium.JulianDate.fromDate(noon);
          viewer.clock.shouldAnimate = false;
        } else if (mode === 'night') {
          // Set to midnight UTC
          const midnight = new Date();
          midnight.setUTCHours(0, 0, 0, 0);
          viewer.clock.currentTime = Cesium.JulianDate.fromDate(midnight);
          viewer.clock.shouldAnimate = false;
        }

        // Update button styles for TOD buttons only
        ['realtime', 'day', 'night'].forEach(m => {
          const btn = document.getElementById(`tod-${m}-btn`);
          if (btn) {
            if (m === mode) {
              btn.classList.remove('btn-outline-warning', 'btn-outline-secondary', 'btn-outline-light');
              btn.classList.add('btn-accent');
            } else {
              btn.classList.remove('btn-accent');
              if (m === 'day') btn.classList.add('btn-outline-warning');
              else if (m === 'night') btn.classList.add('btn-outline-secondary');
              else btn.classList.add('btn-outline-light');
            }
          }
        });
      }

      function toggleGlobeLighting(enabled) {
        if (viewer.scene.globe) {
          viewer.scene.globe.enableLighting = enabled;
          viewer.scene.globe.dynamicAtmosphereLighting = enabled;
          viewer.scene.globe.dynamicAtmosphereLightingFromSun = enabled;
        }
        // Toggle sun/moon visibility and scene light
        viewer.scene.sun.show = enabled;
        viewer.scene.moon.show = enabled;

        // Toggle between SunLight and default DirectionalLight
        if (enabled) {
          viewer.scene.light = new Cesium.SunLight();
        } else {
          // Use fixed directional light (noon-like)
          viewer.scene.light = new Cesium.DirectionalLight({
            direction: new Cesium.Cartesian3(0.0, 0.0, 1.0)
          });
        }
        console.log("Globe lighting:", enabled);
      }

      // ========== CESIUM ION ACCESS TOKEN ==========
      // Using user's Cesium Ion token for Google Photorealistic 3D Tiles
      Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlNzYzZDA0ZC0xMzM2LTRiZDYtOTlmYi00YWZlYWIyMmIzZDQiLCJpZCI6Mzc5MzIwLCJpYXQiOjE3Njg1MTI0NTV9.SFfIGeLNyHKRsAD8oJdDHpNibeSoxx_ISirSN1-xKdg";

      // Initialize Viewer with globe for lighting effects
      var viewer = new Cesium.Viewer('cesiumContainer', {
        // Enable globe for day/night lighting (Option A)
        globe: new Cesium.Globe(Cesium.Ellipsoid.WGS84),
        skyAtmosphere: new Cesium.SkyAtmosphere(), // Atmosphere effects
        geocoder: Cesium.IonGeocodeProviderType.GOOGLE, // Use Google geocoder
        homeButton: false,
        baseLayerPicker: false, // 3D tiles don't support imagery layers
        infoBox: false,
        sceneModePicker: false, // 2D/Columbus not supported for global 3D tiles
        animation: false,
        selectionIndicator: false,
        fullscreenButton: false,
        timeline: false,
        navigationHelpButton: false,
        // Shadows for 3D effect (optional, can be heavy)
        shadows: false
      });

      // ========== ENABLE DYNAMIC LIGHTING ==========
      // Sun-based lighting creates day/night cycle on the globe
      viewer.scene.globe.enableLighting = true;
      viewer.scene.sun.show = true;
      viewer.scene.moon.show = true;

      // Use sun-based directional light for 3D tiles
      viewer.scene.light = new Cesium.SunLight();

      // Enable dynamic atmosphere lighting based on sun position
      viewer.scene.globe.dynamicAtmosphereLighting = true;
      viewer.scene.globe.dynamicAtmosphereLightingFromSun = true;

      // Set clock to real-time by default
      viewer.clock.currentTime = Cesium.JulianDate.now();
      viewer.clock.shouldAnimate = true;
      viewer.clock.multiplier = 1;

      // Add Google Photorealistic 3D Tiles (Asset ID: 2275207)
      (async () => {
        try {
          const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(2275207);
          viewer.scene.primitives.add(tileset);
          console.log("Google Photorealistic 3D Tiles loaded successfully");
        } catch (error) {
          console.error("Failed to load 3D Tiles:", error);
          // Fallback to 2D imagery if 3D tiles fail
          try {
            const esriImagery = new Cesium.UrlTemplateImageryProvider({
              url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
              credit: 'Esri, Maxar, Earthstar Geographics, and the GIS User Community'
            });
            viewer.imageryLayers.addImageryProvider(esriImagery);
            console.log("Fallback: Esri Imagery loaded");
          } catch (e) {
            console.error("Fallback imagery also failed", e);
          }
        }
      })();

      // Set default view to Irvine, CA
      viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(-117.8265, 33.6846, 2000), // Lower altitude for 3D effect
        orientation: {
          heading: Cesium.Math.toRadians(0),
          pitch: Cesium.Math.toRadians(-45), // Angled view for 3D tiles
          roll: 0
        }
      });

      // Update Cockpit View every tick
      viewer.clock.onTick.addEventListener(function (clock) {
        if (cameraMode === 'cockpit' && trackedDroneId && droneEntities.has(trackedDroneId)) {
          try {
            const entity = droneEntities.get(trackedDroneId);
            if (!entity || !entity.position) return;

            const position = entity.position.getValue(clock.currentTime);
            if (!position) return;

            // Check if orientation exists (some entities may not have it)
            let heading = 0, pitch = 0, roll = 0;
            if (entity.orientation) {
              const orientation = entity.orientation.getValue(clock.currentTime);
              if (orientation) {
                const hpr = Cesium.HeadingPitchRoll.fromQuaternion(orientation);
                heading = hpr.heading;
                pitch = hpr.pitch;
                roll = hpr.roll;
              }
            } else {
              // Fallback: Use droneData heading if available
              const data = droneData.get(trackedDroneId);
              if (data && data.heading) {
                heading = Cesium.Math.toRadians(data.heading);
              }
              pitch = Cesium.Math.toRadians(-15); // Slight downward tilt for FPV
            }

            viewer.camera.setView({
              destination: position,
              orientation: {
                heading: heading,
                pitch: pitch,
                roll: roll
              }
            });
          } catch (e) {
            console.warn('Cockpit camera error:', e);
          }
        }
      });

      // Track drones by ID and their position history
      const droneEntities = new Map(); // id -> entity
      const droneTrails = new Map(); // Store trail positions
      const flightPlans = new Map(); // Store flight plans locally
      let selectedRouteEntity = null; // Track currently displayed route

      // Poll for flight plans
      async function fetchFlightPlans() {
        try {
          const response = await fetch('http://localhost:3000/v1/flights');
          if (response.ok) {
            const plans = await response.json();
            plans.forEach(plan => {
              flightPlans.set(plan.drone_id, plan);
            });
          }
        } catch (e) {
          console.warn('Failed to fetch flight plans:', e);
        }
      }
      setInterval(fetchFlightPlans, 5000); // Fetch every 5s
      fetchFlightPlans(); // Initial fetch

      // ========== CONFLICT VISUALIZATION ==========
      const conflictEntities = new Map(); // conflict_id -> entity
      let activeConflicts = [];

      async function fetchConflicts() {
        try {
          const response = await fetch('http://localhost:3000/v1/conflicts');
          if (response.ok) {
            const conflicts = await response.json();
            activeConflicts = conflicts;
            renderConflicts(conflicts);
          }
        } catch (e) {
          // ATC server might not be running - silently ignore
        }
      }

      function renderConflicts(conflicts) {
        // Remove old conflict entities that are no longer active
        const currentConflictIds = new Set(conflicts.map(c => `${c.drone1_id}-${c.drone2_id}`));
        for (const [id, entity] of conflictEntities) {
          if (!currentConflictIds.has(id)) {
            viewer.entities.remove(entity);
            conflictEntities.delete(id);
          }
        }

        // Add/update conflict lines
        for (const conflict of conflicts) {
          const conflictId = `${conflict.drone1_id}-${conflict.drone2_id}`;

          // Get drone positions
          const drone1 = droneEntities.get(conflict.drone1_id);
          const drone2 = droneEntities.get(conflict.drone2_id);

          if (!drone1 || !drone2) continue;

          // Get current positions from entities
          const pos1 = drone1.position?.getValue(viewer.clock.currentTime);
          const pos2 = drone2.position?.getValue(viewer.clock.currentTime);

          if (!pos1 || !pos2) continue;

          // Color based on severity
          let lineColor, lineWidth;
          if (conflict.severity === 'critical') {
            lineColor = Cesium.Color.RED;
            lineWidth = 4;
          } else if (conflict.severity === 'warning') {
            lineColor = Cesium.Color.ORANGE;
            lineWidth = 3;
          } else {
            lineColor = Cesium.Color.YELLOW;
            lineWidth = 2;
          }

          if (conflictEntities.has(conflictId)) {
            // Update existing line
            const entity = conflictEntities.get(conflictId);
            entity.polyline.positions = [pos1, pos2];
          } else {
            // Create new conflict line
            const entity = viewer.entities.add({
              id: `conflict-${conflictId}`,
              polyline: {
                positions: [pos1, pos2],
                width: lineWidth,
                material: new Cesium.PolylineGlowMaterialProperty({
                  glowPower: 0.3,
                  color: lineColor
                })
              },
              description: `
                <table class="cesium-infoBox-defaultTable">
                  <tr><td>Drones:</td><td>${conflict.drone1_id} ↔ ${conflict.drone2_id}</td></tr>
                  <tr><td>Distance:</td><td>${conflict.distance_m.toFixed(0)} m</td></tr>
                  <tr><td>Severity:</td><td style="color: ${lineColor.toCssColorString()}">${conflict.severity.toUpperCase()}</td></tr>
                  <tr><td>Time to Closest:</td><td>${conflict.time_to_closest.toFixed(1)} s</td></tr>
                </table>
              `
            });
            conflictEntities.set(conflictId, entity);

            console.log(`[CONFLICT] ${conflict.severity.toUpperCase()}: ${conflict.drone1_id} <-> ${conflict.drone2_id} (${conflict.distance_m.toFixed(0)}m)`);
          }

          // Update drone model colors based on conflict severity
          if (conflict.severity === 'critical') {
            if (drone1.model) drone1.model.silhouetteColor = Cesium.Color.RED;
            if (drone2.model) drone2.model.silhouetteColor = Cesium.Color.RED;
          } else if (conflict.severity === 'warning') {
            if (drone1.model) drone1.model.silhouetteColor = Cesium.Color.ORANGE;
            if (drone2.model) drone2.model.silhouetteColor = Cesium.Color.ORANGE;
          }
        }

        // Reset non-conflicting drones to default color
        const conflictingDrones = new Set();
        conflicts.forEach(c => {
          conflictingDrones.add(c.drone1_id);
          conflictingDrones.add(c.drone2_id);
        });
        for (const [id, entity] of droneEntities) {
          if (!conflictingDrones.has(id) && entity.model) {
            entity.model.silhouetteColor = Cesium.Color.CYAN; // Default color
          }
        }
      }

      // Poll conflicts every 2 seconds
      setInterval(fetchConflicts, 2000);
      fetchConflicts(); // Initial fetch

      // ========== GEOFENCE VISUALIZATION ==========
      const geofenceEntities = new Map(); // geofence_id -> entity

      async function fetchGeofences() {
        try {
          const response = await fetch('http://localhost:3000/v1/geofences');
          if (response.ok) {
            const geofences = await response.json();
            renderGeofences(geofences);
          }
        } catch (e) {
          // ATC server might not be running - silently ignore
        }
      }

      function renderGeofences(geofences) {
        // Remove old geofence entities that no longer exist
        const currentIds = new Set(geofences.map(g => g.id));
        for (const [id, entity] of geofenceEntities) {
          if (!currentIds.has(id)) {
            viewer.entities.remove(entity);
            geofenceEntities.delete(id);
          }
        }

        for (const geofence of geofences) {
          if (geofenceEntities.has(geofence.id)) continue; // Already rendered

          // Convert polygon [lat, lon] to Cesium positions
          const positions = geofence.polygon.map(([lat, lon]) =>
            Cesium.Cartesian3.fromDegrees(lon, lat, geofence.upper_altitude_m)
          );

          // Color based on type
          let fillColor, outlineColor;
          switch (geofence.geofence_type) {
            case 'no_fly_zone':
              fillColor = Cesium.Color.RED.withAlpha(0.3);
              outlineColor = Cesium.Color.RED;
              break;
            case 'restricted_area':
              fillColor = Cesium.Color.ORANGE.withAlpha(0.25);
              outlineColor = Cesium.Color.ORANGE;
              break;
            case 'temporary_restriction':
              fillColor = Cesium.Color.YELLOW.withAlpha(0.2);
              outlineColor = Cesium.Color.YELLOW;
              break;
            default:
              fillColor = Cesium.Color.BLUE.withAlpha(0.15);
              outlineColor = Cesium.Color.BLUE;
          }

          const entity = viewer.entities.add({
            id: `geofence-${geofence.id}`,
            name: geofence.name,
            polygon: {
              hierarchy: positions,
              height: geofence.lower_altitude_m,
              extrudedHeight: geofence.upper_altitude_m,
              material: fillColor,
              outline: true,
              outlineColor: outlineColor,
              outlineWidth: 2
            },
            description: `
              <table class="cesium-infoBox-defaultTable">
                <tr><td>Name:</td><td>${geofence.name}</td></tr>
                <tr><td>Type:</td><td>${geofence.geofence_type.replace('_', ' ').toUpperCase()}</td></tr>
                <tr><td>Floor:</td><td>${geofence.lower_altitude_m} m</td></tr>
                <tr><td>Ceiling:</td><td>${geofence.upper_altitude_m} m</td></tr>
                <tr><td>Status:</td><td>${geofence.active ? 'Active' : 'Inactive'}</td></tr>
              </table>
            `
          });
          geofenceEntities.set(geofence.id, entity);
          console.log(`[GEOFENCE] Rendered: ${geofence.name} (${geofence.geofence_type})`);
        }
      }

      // Poll geofences every 10 seconds
      setInterval(fetchGeofences, 10000);
      fetchGeofences(); // Initial fetch

      // Handle selection to show planned route & update camera
      viewer.selectedEntityChanged.addEventListener((entity) => {
        // Remove previous route
        if (selectedRouteEntity) {
          viewer.entities.remove(selectedRouteEntity);
          selectedRouteEntity = null;
        }

        if (entity && flightPlans.has(entity.id)) {
          // 1. Show Route
          const plan = flightPlans.get(entity.id);
          const positions = plan.waypoints.map(wp =>
            Cesium.Cartesian3.fromDegrees(wp.lon, wp.lat, wp.altitude_m)
          );

          selectedRouteEntity = viewer.entities.add({
            polyline: {
              positions: positions,
              width: 2,
              material: new Cesium.PolylineDashMaterialProperty({
                color: Cesium.Color.fromCssColorString('#10b981'), // Emerald-500
                dashLength: 16.0
              })
            }
          });
        }

        // 2. Update Camera Tracking
        if (entity && droneEntities.has(entity.id)) {
          trackedDroneId = entity.id;
          if (cameraMode === 'orbit') {
            viewer.trackedEntity = entity;
          }
          // If Cockpit, tick loop picks up trackedDroneId automatically
        } else {
          trackedDroneId = null;
          if (cameraMode === 'orbit') {
            viewer.trackedEntity = undefined;
          }
        }
      });
      const droneData = new Map(); // id -> {lat, lon, alt, speed, heading}
      const MAX_TRAIL_POINTS = 60; // Keep last 60 positions (1 min at 1Hz)

      // Update the flight list UI
      function updateFlightList() {
        const tbody = document.getElementById('flight-list-body');
        const countBadge = document.getElementById('flight-count');
        if (!tbody) return;

        tbody.innerHTML = '';
        let count = 0;

        droneData.forEach((data, droneId) => {
          count++;
          const row = document.createElement('tr');
          // Add cursor pointer for interactivity
          row.style.cursor = 'pointer';

          /* 
            Premium UI Table Row 
            Using data.speed || 0 to ensure we don't show NaN or undefined
          */
          row.innerHTML = `
            <td class="ps-3"><span class="fw-medium text-accent">${droneId}</span></td>
            <td><span class="text-white">${data.alt.toFixed(0)}</span> <small class="text-muted">m</small></td>
            <td><span class="text-white">${(data.speed || 0).toFixed(1)}</span> <small class="text-muted">m/s</small></td>
          `;

          row.onclick = () => {
            const entity = droneEntities.get(droneId);
            if (entity) {
              viewer.selectedEntity = entity; // Trigger selection logic
              // Only flyTo if not in Cockpit mode (avoids jarring shift)
              if (cameraMode !== 'cockpit') {
                viewer.flyTo(entity, { duration: 1.5 });
              }
            }
          };
          tbody.appendChild(row);
        });

        if (countBadge) countBadge.textContent = count;
      }

      /* Theme Toggler Logic */
      function toggleTheme() {
        const body = document.body;
        const icon = document.getElementById('theme-icon');

        if (body.getAttribute('data-theme') === 'light') {
          body.setAttribute('data-theme', 'dark');
          icon.classList.remove('bi-moon-fill');
          icon.classList.add('bi-sun-fill');
          localStorage.setItem('theme', 'dark');
        } else {
          body.setAttribute('data-theme', 'light');
          icon.classList.remove('bi-sun-fill');
          icon.classList.add('bi-moon-fill');
          localStorage.setItem('theme', 'light');
        }
      }

      // Load saved theme
      if (localStorage.getItem('theme') === 'light') {
        document.body.setAttribute('data-theme', 'light');
        document.addEventListener('DOMContentLoaded', () => {
          const icon = document.getElementById('theme-icon');
          if (icon) {
            icon.classList.remove('bi-sun-fill');
            icon.classList.add('bi-moon-fill');
          }
        });
      }

      function updateDronePosition(droneId, lon, lat, altMeters, heading, speed) {
        try {
          const validLon = Number(lon) || 0;
          const validLat = Number(lat) || 0;
          const validAlt = Number(altMeters) || 0;

          if (validLon === 0 && validLat === 0) return; // Skip invalid 0,0 points

          const position = Cesium.Cartesian3.fromDegrees(validLon, validLat, validAlt);

          // Update trail history
          if (!droneTrails.has(droneId)) {
            droneTrails.set(droneId, []);
          }
          const trail = droneTrails.get(droneId);
          trail.push(position);
          if (trail.length > MAX_TRAIL_POINTS) {
            trail.shift();
          }

          // Update or create drone entity
          const description = `
            <table class="table table-sm table-borderless text-white mb-0">
              <tbody>
                <tr><td>ID:</td><td class="fw-bold">${droneId}</td></tr>
                <tr><td>Speed:</td><td>${(speed || 0).toFixed(1)} m/s</td></tr>
                <tr><td>Heading:</td><td>${(heading || 0).toFixed(0)}°</td></tr>
                <tr><td>Altitude:</td><td>${altMeters.toFixed(0)} m</td></tr>
                <tr><td>Lat/Lon:</td><td>${lat.toFixed(5)}, ${lon.toFixed(5)}</td></tr>
              </tbody>
            </table>
          `;

          if (!droneEntities.has(droneId)) {
            console.log(`Creating drone ${droneId} at ${validLat}, ${validLon}`);

            // Calculate orientation quaternion from heading
            const headingRad = Cesium.Math.toRadians(heading || 0);
            const hpr = new Cesium.HeadingPitchRoll(headingRad, 0, 0);
            const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);

            const entity = viewer.entities.add({
              id: droneId,
              name: `Drone ${droneId}`, // Title for InfoBox
              position: position, // Initial position
              orientation: orientation,
              // 3D Drone Model instead of point
              model: {
                uri: '/assets/models/drone.glb',
                minimumPixelSize: 32,      // Minimum screen size
                maximumScale: 200,         // Maximum world scale
                scale: 0.5,                // Base scale (adjust based on model size)
                silhouetteColor: Cesium.Color.CYAN,
                silhouetteSize: 1.5,
                colorBlendMode: Cesium.ColorBlendMode.HIGHLIGHT,
                colorBlendAmount: 0.0
              },
              label: {
                text: `${droneId}\n${(speed || 0).toFixed(1)} m/s`, // Multi-line label
                font: '12px Inter',
                fillColor: Cesium.Color.WHITE,
                showBackground: true,
                backgroundColor: Cesium.Color.fromCssColorString('#0f172a').withAlpha(0.7), // Slate-900
                backgroundPadding: new Cesium.Cartesian2(4, 4),
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                pixelOffset: new Cesium.Cartesian2(0, -40), // Raised for 3D model
                distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 5000) // Hide when zoomed out
              },
              description: description,
              polyline: {
                positions: new Cesium.CallbackProperty(() => droneTrails.get(droneId), false),
                width: 3,
                material: new Cesium.PolylineGlowMaterialProperty({
                  glowPower: 0.2,
                  color: Cesium.Color.YELLOW
                })
              }
            });
            droneEntities.set(droneId, entity);
          } else {
            const entity = droneEntities.get(droneId);
            entity.position = position;

            // Update orientation based on heading
            const headingRad = Cesium.Math.toRadians(heading || 0);
            const hpr = new Cesium.HeadingPitchRoll(headingRad, 0, 0);
            entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);

            // Update dynamic properties
            entity.description = description;
            entity.label.text = `${droneId}\n${(speed || 0).toFixed(1)} m/s`;
          }

          // Update droneData for flight list
          droneData.set(droneId, { lat: validLat, lon: validLon, alt: validAlt, speed, heading });
          updateFlightList();
        } catch (error) {
          console.error("Error in updateDronePosition:", error);
        }
      }

      function clearAllDrones() {
        droneEntities.forEach((entity) => viewer.entities.remove(entity));
        droneEntities.clear();
        droneTrails.clear();
        droneData.clear();
        updateFlightList();
      }

      // Subscribe to changes in selectedEntity
      viewer.selectedEntityChanged.addEventListener(function (entity) {
        if (entity) {
          clicked_entity.innerHTML = "";
          // Display custom UI or pop-up with entity properties
          if (entity.description) {
            clicked_entity.innerHTML = entity.description.getValue();
          } else {
            clicked_entity.innerHTML = "No additional information available.";
          }
        }
      });
      var scene = viewer.scene;
      var clock = viewer.clock;
      var camera = viewer.camera;

      var cameralat;
      var cameralng;


      camera.moveStart.addEventListener(function () {
        // the camera started to move
      });
      camera.moveEnd.addEventListener(function () {
        // the camera stopped moving
        let center = get_globe_center();
        const lat_cont = document.getElementById('spotlight_latitude');
        const lng_cont = document.getElementById('spotlight_longitude');
        lat_cont.innerText = parseFloat(center.lat).toFixed(2);
        lng_cont.innerText = parseFloat(center.lng).toFixed(2);
      });
      function remove_spaces(string) {
        return string.replace(/\n/g, "").replace(/ /g, '');
      }
      function get_globe_center() {
        var windowPosition = new Cesium.Cartesian2(viewer.container.clientWidth / 2, viewer.container.clientHeight / 2);
        var pickPosition = viewer.camera.pickEllipsoid(windowPosition, Cesium.Ellipsoid.WGS84);
        if (!pickPosition) {
          return { "lat": 0, "lng": 0 };
        }
        // Use Cesium.Ellipsoid.WGS84 directly (globe may be disabled for 3D tiles)
        var pickPositionCartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(pickPosition);
        const lng = pickPositionCartographic.longitude * (180 / Math.PI);
        const lat = pickPositionCartographic.latitude * (180 / Math.PI);

        return { "lat": lat, "lng": lng };
      }


      function stream_flights() {
        const center = get_globe_center();
        // If we are essentially at 0,0 (start) or user wants default, use Irvine
        let lat = center['lat'];
        let lng = center['lng'];
        // Default to Irvine if user hasn't moved much or it's 0,0
        if (Math.abs(lat) < 1 && Math.abs(lng) < 1) {
          lat = 33.6846;
          lng = -117.8265;
        }
        let url = '?lat=' + lat + '&lng=' + lng;
        window.location.href = url;
      }


      const map_querystring = window.location.search;
      const date_params = new URLSearchParams(map_querystring);

      let lat = date_params.get('lat');
      let lng = date_params.get('lng');

      if (!lat) {
        lat = 0;
      }

      if (!lng) {
        lng = 0;
      }

      // Auto-stream: If no coordinates provided, redirect with Irvine defaults
      if (lat == 0 && lng == 0) {
        // Auto-redirect to stream flights centered on Irvine
        window.location.href = '?lat=33.6846&lng=-117.8265';
      }

      // Robust data loading: Parse from the JSON script block explicitly
      let view_data = {};
      try {
        const el = document.getElementById('server_data');
        if (el && el.textContent) {
          view_data = JSON.parse(el.textContent);
        }
      } catch (e) {
        console.error("Data parse error", e);
      }

      if (lat !== 0 && lng !== 0) {

        let manual_spotlight_controls_cont = document.getElementById('manual_spotlight_controls');
        manual_spotlight_controls_cont.classList.add('d-none');
        const lat_cont = document.getElementById('spotlight_latitude');
        const lng_cont = document.getElementById('spotlight_longitude');
        lat_cont.innerText = parseFloat(lat).toFixed(2);
        lng_cont.innerText = parseFloat(lng).toFixed(2);

        // Safely load AOI buffer if available
        if (view_data && view_data['aoi_buffer']) {
          let aoi_buffer = view_data['aoi_buffer'];
          let aoi = viewer.dataSources.add(Cesium.GeoJsonDataSource.load(aoi_buffer, {
            stroke: Cesium.Color.BLACK,
            fill: Cesium.Color.WHITE.withAlpha(0.2),
            strokeWidth: 3
          }));
          viewer.zoomTo(aoi);
        }

        let spinner_cont = document.getElementById("spinner-cont");
        spinner_cont.classList.remove("d-none"); // Show spinner

        if (view_data && view_data['msg']) {
          humane.log(view_data['msg'], {
            addnCls: 'humane-flatty-success'
          });
        }

        let socket = io.connect(socketHost);
        socket.on('connect_failed', function () {
          errorMsg('Data connection failed, please contact your administrator.');
        });
        socket.on('disconnect', function () {
          console.log('disconnected');
        });
        socket.on('welcome', function (msg) {
          console.log('Welcome message:', msg);
        });
        socket.on('connect', function () {
          socket.emit('room', email);
        });
        socket.on('connect_timeout', function () {
          console.log("timed out");

        });
        socket.on('message', function (spotlight_data) {
          if (spotlight_data.type == 'message') {
            if (spotlight_data.alert_type == 'observation_in_aoi') {
              const cur_result = spotlight_data.results.object;
              const droneId = spotlight_data.results.id;
              const lon = cur_result.coordinates[0];
              const lat = cur_result.coordinates[1];
              const altMeters = cur_result.coordinates[2] / 1000; // mm to m

              // Metadata is stored as JSON string in Tile38 fields, not in object
              // Try fields.metadata first (Tile38), fall back to object.metadata (direct)
              let metadata = {};
              try {
                if (spotlight_data.results.fields && spotlight_data.results.fields.metadata) {
                  if (typeof spotlight_data.results.fields.metadata === 'string') {
                    try {
                      metadata = JSON.parse(spotlight_data.results.fields.metadata);
                    } catch (e) {
                      console.warn("Error parsing fields metadata", e);
                    }
                  } else {
                    metadata = spotlight_data.results.fields.metadata;
                  }
                } else if (cur_result.metadata) {
                  metadata = cur_result.metadata;
                }
              } catch (e) {
                console.warn('Failed to parse metadata:', e);
              }

              const heading = metadata.heading || 0;
              const speed = metadata.speed_mps || 0;

              // Debug log to verify data
              if (speed > 0 || heading !== 0) {
                console.log(`[${droneId}] Speed: ${speed.toFixed(1)} m/s, Heading: ${heading.toFixed(0)}°`);
              }

              updateDronePosition(droneId, lon, lat, altMeters, heading, speed);
            } else if (spotlight_data.alert_type == 'aoi_closed') {
              // GeoFence Closed - Clear all traffic
              clearAllDrones();
              viewer.dataSources.removeAll();
              humane.log("Airspace scanning closed", {
                addnCls: 'humane-flatty-info'
              });

              let spinner_cont = document.getElementById("spinner-cont");
              spinner_cont.classList.add("d-none");

              let manual_spotlight_controls_cont = document.getElementById('manual_spotlight_controls');
              manual_spotlight_controls_cont.classList.remove('d-none');
              clearList();

            }
            else if (spotlight_data.alert_type == 'geo_fence_in_aoi') {
              const result_geo_json = spotlight_data.results.objects;

              for (let index = 0; index < result_geo_json.length; index++) {
                const geo_json_element = result_geo_json[index]['object'];
                const geo_fence_heights = result_geo_json[index]['fields'];
                var dataSource = Cesium.GeoJsonDataSource.load(geo_json_element).then(
                  function (dataSource) {
                    var p = dataSource.entities.values;
                    for (var i = 0; i < p.length; i++) {
                      p[i].polygon.height = geo_fence_heights[1]; // or height property
                      p[i].polygon.extrudedHeight = geo_fence_heights[
                        0]; // or height property
                      p[i].polygon.outlineColor = Cesium.Color.PINK.withAlpha(0.2),
                        p[i].polygon.material = Cesium.Color.HOTPINK.withAlpha(0.2)
                    }
                    viewer.dataSources.add(dataSource);
                  }
                );
              }
            }
            else if (spotlight_data.alert_type == 'operational_intents_in_aoi') {
              const result_geo_json = spotlight_data.results.objects;

              for (let index = 0; index < result_geo_json.length; index++) {
                const geo_json_element = result_geo_json[index]['object'];

                const flight_declaration_fields = result_geo_json[index]['fields'];
                const heights = flight_declaration_fields.filter(item => typeof item === 'number');
                const minHeight = Math.min(...heights);
                const maxHeight = Math.max(...heights);
                const strings = flight_declaration_fields.filter(item => typeof item === 'string');
                const [id, manager, state] = strings;
                let dataSource = Cesium.GeoJsonDataSource.load(geo_json_element).then(
                  function (dataSource) {
                    var p = dataSource.entities.values;
                    for (var i = 0; i < p.length; i++) {
                      p[i].polygon.height = minHeight; // or height property
                      p[i].polygon.extrudedHeight = maxHeight; // or height property
                      p[i].polygon.outlineColor = Cesium.Color.WHITE.withAlpha(0.2),
                        p[i].polygon.material = Cesium.Color.YELLOW.withAlpha(0.2)
                      p[i].description = `ID: ${id}<br>Manager: ${manager}<br>State: ${state}`;
                    }
                    viewer.dataSources.add(dataSource);

                  }
                );

              }
            }
            else if (spotlight_data.alert_type == 'observation_crosses_geofence') {
              let d = new Date();
              addToList('<span class="date">' + d.toLocaleTimeString() + '</span> ' + spotlight_data.results);

            }
          }
        });
      }
      else {
        let center = get_globe_center();
        const lat_cont = document.getElementById('spotlight_latitude');
        const lng_cont = document.getElementById('spotlight_longitude');
        lat_cont.innerText = parseFloat(center.lat).toFixed(2);
        lng_cont.innerText = parseFloat(center.lng).toFixed(2);

      }
    </script>
</body>

</html>